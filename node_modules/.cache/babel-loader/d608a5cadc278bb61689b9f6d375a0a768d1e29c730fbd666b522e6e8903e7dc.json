{"ast":null,"code":"/* Copyright 2016 Yury Karpovich\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n MSG Reader\n */\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['./DataStream'], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory(require('./DataStream'));\n  } else {\n    // Browser globals (root is window)\n    root.MSGReader = factory(root.DataStream);\n  }\n})(this, function (DataStream) {\n  // constants\n  var CONST = {\n    FILE_HEADER: uInt2int([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),\n    MSG: {\n      UNUSED_BLOCK: -1,\n      END_OF_CHAIN: -2,\n      S_BIG_BLOCK_SIZE: 0x0200,\n      S_BIG_BLOCK_MARK: 9,\n      L_BIG_BLOCK_SIZE: 0x1000,\n      L_BIG_BLOCK_MARK: 12,\n      SMALL_BLOCK_SIZE: 0x0040,\n      BIG_BLOCK_MIN_DOC_SIZE: 0x1000,\n      HEADER: {\n        PROPERTY_START_OFFSET: 0x30,\n        BAT_START_OFFSET: 0x4c,\n        BAT_COUNT_OFFSET: 0x2C,\n        SBAT_START_OFFSET: 0x3C,\n        SBAT_COUNT_OFFSET: 0x40,\n        XBAT_START_OFFSET: 0x44,\n        XBAT_COUNT_OFFSET: 0x48\n      },\n      PROP: {\n        NO_INDEX: -1,\n        PROPERTY_SIZE: 0x0080,\n        NAME_SIZE_OFFSET: 0x40,\n        MAX_NAME_LENGTH: ( /*NAME_SIZE_OFFSET*/0x40 / 2) - 1,\n        TYPE_OFFSET: 0x42,\n        PREVIOUS_PROPERTY_OFFSET: 0x44,\n        NEXT_PROPERTY_OFFSET: 0x48,\n        CHILD_PROPERTY_OFFSET: 0x4C,\n        START_BLOCK_OFFSET: 0x74,\n        SIZE_OFFSET: 0x78,\n        TYPE_ENUM: {\n          DIRECTORY: 1,\n          DOCUMENT: 2,\n          ROOT: 5\n        }\n      },\n      FIELD: {\n        PREFIX: {\n          ATTACHMENT: '__attach_version1.0',\n          RECIPIENT: '__recip_version1.0',\n          DOCUMENT: '__substg1.'\n        },\n        // example (use fields as needed)\n        NAME_MAPPING: {\n          // email specific\n          '0037': 'subject',\n          '0c1a': 'senderName',\n          '5d02': 'senderEmail',\n          '1000': 'body',\n          '007d': 'headers',\n          // attachment specific\n          '3703': 'extension',\n          '3704': 'fileNameShort',\n          '3707': 'fileName',\n          '3712': 'pidContentId',\n          // recipient specific\n          '3001': 'name',\n          '39fe': 'email'\n        },\n        CLASS_MAPPING: {\n          ATTACHMENT_DATA: '3701'\n        },\n        TYPE_MAPPING: {\n          '001e': 'string',\n          '001f': 'unicode',\n          '0102': 'binary'\n        },\n        DIR_TYPE: {\n          INNER_MSG: '000d'\n        }\n      }\n    }\n  };\n\n  // unit utils\n  function arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  function uInt2int(data) {\n    var result = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      result[i] = data[i] << 24 >> 24;\n    }\n    return result;\n  }\n\n  // MSG Reader implementation\n\n  // check MSG file header\n  function isMSGFile(ds) {\n    ds.seek(0);\n    return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));\n  }\n\n  // FAT utils\n  function getBlockOffsetAt(msgData, offset) {\n    return (offset + 1) * msgData.bigBlockSize;\n  }\n  function getBlockAt(ds, msgData, offset) {\n    var startOffset = getBlockOffsetAt(msgData, offset);\n    ds.seek(startOffset);\n    return ds.readInt32Array(msgData.bigBlockLength);\n  }\n  function getNextBlockInner(ds, msgData, offset, blockOffsetData) {\n    var currentBlock = Math.floor(offset / msgData.bigBlockLength);\n    var currentBlockIndex = offset % msgData.bigBlockLength;\n    var startBlockOffset = blockOffsetData[currentBlock];\n    return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];\n  }\n  function getNextBlock(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.batData);\n  }\n  function getNextBlockSmall(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.sbatData);\n  }\n\n  // convert binary data to dictionary\n  function parseMsgData(ds) {\n    var msgData = headerData(ds);\n    msgData.batData = batData(ds, msgData);\n    msgData.sbatData = sbatData(ds, msgData);\n    if (msgData.xbatCount > 0) {\n      xbatData(ds, msgData);\n    }\n    msgData.propertyData = propertyData(ds, msgData);\n    msgData.fieldsData = fieldsData(ds, msgData);\n    return msgData;\n  }\n\n  // extract header data\n  function headerData(ds) {\n    var headerData = {};\n\n    // system data\n    headerData.bigBlockSize = ds.readByte( /*const position*/30) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;\n    headerData.bigBlockLength = headerData.bigBlockSize / 4;\n    headerData.xBlockLength = headerData.bigBlockLength - 1;\n\n    // header data\n    headerData.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);\n    headerData.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);\n    headerData.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);\n    headerData.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);\n    headerData.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);\n    headerData.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);\n    return headerData;\n  }\n  function batCountInHeader(msgData) {\n    var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;\n    return Math.min(msgData.batCount, maxBatsInHeader);\n  }\n  function batData(ds, msgData) {\n    var result = new Array(batCountInHeader(msgData));\n    ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);\n    for (var i = 0; i < result.length; i++) {\n      result[i] = ds.readInt32();\n    }\n    return result;\n  }\n  function sbatData(ds, msgData) {\n    var result = [];\n    var startIndex = msgData.sbatStart;\n    for (var i = 0; i < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i++) {\n      result.push(startIndex);\n      startIndex = getNextBlock(ds, msgData, startIndex);\n    }\n    return result;\n  }\n  function xbatData(ds, msgData) {\n    var batCount = batCountInHeader(msgData);\n    var batCountTotal = msgData.batCount;\n    var remainingBlocks = batCountTotal - batCount;\n    var nextBlockAt = msgData.xbatStart;\n    for (var i = 0; i < msgData.xbatCount; i++) {\n      var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);\n      nextBlockAt = xBatBlock[msgData.xBlockLength];\n      var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);\n      for (var j = 0; j < blocksToProcess; j++) {\n        var blockStartAt = xBatBlock[j];\n        if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {\n          break;\n        }\n        msgData.batData.push(blockStartAt);\n      }\n      remainingBlocks -= blocksToProcess;\n    }\n  }\n\n  // extract property data and property hierarchy\n  function propertyData(ds, msgData) {\n    var props = [];\n    var currentOffset = msgData.propertyStart;\n    while (currentOffset != CONST.MSG.END_OF_CHAIN) {\n      convertBlockToProperties(ds, msgData, currentOffset, props);\n      currentOffset = getNextBlock(ds, msgData, currentOffset);\n    }\n    createPropertyHierarchy(props, /*property with index 0 (zero) always as root*/props[0]);\n    return props;\n  }\n  function convertName(ds, offset) {\n    var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);\n    if (nameLength < 1) {\n      return '';\n    } else {\n      return ds.readStringAt(offset, nameLength / 2);\n    }\n  }\n  function convertProperty(ds, index, offset) {\n    return {\n      index: index,\n      type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),\n      name: convertName(ds, offset),\n      // hierarchy\n      previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),\n      nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),\n      childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),\n      // data offset\n      startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),\n      sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)\n    };\n  }\n  function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {\n    var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;\n    var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);\n    for (var i = 0; i < propertyCount; i++) {\n      var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);\n      switch (propertyType) {\n        case CONST.MSG.PROP.TYPE_ENUM.ROOT:\n        case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:\n        case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:\n          props.push(convertProperty(ds, props.length, propertyOffset));\n          break;\n        default:\n          /* unknown property types */\n          props.push(null);\n      }\n      propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;\n    }\n  }\n  function createPropertyHierarchy(props, nodeProperty) {\n    if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {\n      return;\n    }\n    nodeProperty.children = [];\n    var children = [nodeProperty.childProperty];\n    while (children.length != 0) {\n      var currentIndex = children.shift();\n      var current = props[currentIndex];\n      if (current == null) {\n        continue;\n      }\n      nodeProperty.children.push(currentIndex);\n      if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n        createPropertyHierarchy(props, current);\n      }\n      if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.previousProperty);\n      }\n      if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.nextProperty);\n      }\n    }\n  }\n\n  // extract real fields\n  function fieldsData(ds, msgData) {\n    var fields = {\n      attachments: [],\n      recipients: []\n    };\n    fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);\n    return fields;\n  }\n  function fieldsDataDir(ds, msgData, dirProperty, fields) {\n    if (dirProperty.children && dirProperty.children.length > 0) {\n      for (var i = 0; i < dirProperty.children.length; i++) {\n        var childProperty = msgData.propertyData[dirProperty.children[i]];\n        if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n          fieldsDataDirInner(ds, msgData, childProperty, fields);\n        } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {\n          fieldsDataDocument(ds, msgData, childProperty, fields);\n        }\n      }\n    }\n  }\n  function fieldsDataDirInner(ds, msgData, dirProperty, fields) {\n    if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {\n      // attachment\n      var attachmentField = {};\n      fields.attachments.push(attachmentField);\n      fieldsDataDir(ds, msgData, dirProperty, attachmentField);\n    } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {\n      // recipient\n      var recipientField = {};\n      fields.recipients.push(recipientField);\n      fieldsDataDir(ds, msgData, dirProperty, recipientField);\n    } else {\n      // other dir\n      var childFieldType = getFieldType(dirProperty);\n      if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {\n        fieldsDataDir(ds, msgData, dirProperty, fields);\n      } else {\n        // MSG as attachment currently isn't supported\n        fields.innerMsgContent = true;\n      }\n    }\n  }\n  function fieldsDataDocument(ds, msgData, documentProperty, fields) {\n    var value = documentProperty.name.substring(12).toLowerCase();\n    var fieldClass = value.substring(0, 4);\n    var fieldType = value.substring(4, 8);\n    var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];\n    if (fieldName) {\n      fields[fieldName] = getFieldValue(ds, msgData, documentProperty, fieldType);\n    }\n    if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {\n      // attachment specific info\n      fields['dataId'] = documentProperty.index;\n      fields['contentLength'] = documentProperty.sizeBlock;\n    }\n  }\n  function getFieldType(fieldProperty) {\n    var value = fieldProperty.name.substring(12).toLowerCase();\n    return value.substring(4, 8);\n  }\n\n  // extractor structure to manage bat/sbat block types and different data types\n  var extractorFieldValue = {\n    sbat: {\n      'extractor': function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var chain = getChainByBlockSmall(ds, msgData, fieldProperty);\n        if (chain.length == 1) {\n          return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);\n        } else if (chain.length > 1) {\n          return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);\n        }\n        return null;\n      },\n      dataType: {\n        'string': function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readString(blockSize);\n        },\n        'unicode': function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readUCS2String(blockSize / 2);\n        },\n        'binary': function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);\n          return ds.readUint8Array(toReadLength);\n        }\n      }\n    },\n    bat: {\n      'extractor': function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);\n        ds.seek(offset);\n        return dataTypeExtractor(ds, fieldProperty);\n      },\n      dataType: {\n        'string': function extractSbatString(ds, fieldProperty) {\n          return ds.readString(fieldProperty.sizeBlock);\n        },\n        'unicode': function extractSbatUnicode(ds, fieldProperty) {\n          return ds.readUCS2String(fieldProperty.sizeBlock / 2);\n        },\n        'binary': function extractSbatBinary(ds, fieldProperty) {\n          return ds.readUint8Array(fieldProperty.sizeBlock);\n        }\n      }\n    }\n  };\n  function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {\n    var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;\n    var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);\n    var bigBlockOffset = byteOffset % msgData.bigBlockSize;\n    var rootProp = msgData.propertyData[0];\n    var nextBlock = rootProp.startBlock;\n    for (var i = 0; i < bigBlockNumber; i++) {\n      nextBlock = getNextBlock(ds, msgData, nextBlock);\n    }\n    var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);\n    return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);\n  }\n  function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {\n    var resultData = new Int8Array(fieldProperty.sizeBlock);\n    for (var i = 0, idx = 0; i < chain.length; i++) {\n      var data = readDataByBlockSmall(ds, msgData, chain[i], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);\n      for (var j = 0; j < data.length; j++) {\n        resultData[idx++] = data[j];\n      }\n    }\n    var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);\n    return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);\n  }\n  function getChainByBlockSmall(ds, msgData, fieldProperty) {\n    var blockChain = [];\n    var nextBlockSmall = fieldProperty.startBlock;\n    while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {\n      blockChain.push(nextBlockSmall);\n      nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);\n    }\n    return blockChain;\n  }\n  function getFieldValue(ds, msgData, fieldProperty, type) {\n    var value = null;\n    var valueExtractor = fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;\n    var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];\n    if (dataTypeExtractor) {\n      value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);\n    }\n    return value;\n  }\n\n  // MSG Reader\n  var MSGReader = function (arrayBuffer) {\n    this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n  };\n  MSGReader.prototype = {\n    /**\n     Converts bytes to fields information\n      @return {Object} The fields data for MSG file\n     */\n    getFileData: function () {\n      if (!isMSGFile(this.ds)) {\n        return {\n          error: 'Unsupported file type!'\n        };\n      }\n      if (this.fileData == null) {\n        this.fileData = parseMsgData(this.ds);\n      }\n      return this.fileData.fieldsData;\n    },\n    /**\n     Reads an attachment content by key/ID\n      @return {Object} The attachment for specific attachment key\n     */\n    getAttachment: function (attach) {\n      var attachData = typeof attach === 'number' ? this.fileData.fieldsData.attachments[attach] : attach;\n      var fieldProperty = this.fileData.propertyData[attachData.dataId];\n      var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));\n      return {\n        fileName: attachData.fileName,\n        content: fieldData\n      };\n    }\n  };\n  return MSGReader;\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","require","MSGReader","DataStream","CONST","FILE_HEADER","uInt2int","MSG","UNUSED_BLOCK","END_OF_CHAIN","S_BIG_BLOCK_SIZE","S_BIG_BLOCK_MARK","L_BIG_BLOCK_SIZE","L_BIG_BLOCK_MARK","SMALL_BLOCK_SIZE","BIG_BLOCK_MIN_DOC_SIZE","HEADER","PROPERTY_START_OFFSET","BAT_START_OFFSET","BAT_COUNT_OFFSET","SBAT_START_OFFSET","SBAT_COUNT_OFFSET","XBAT_START_OFFSET","XBAT_COUNT_OFFSET","PROP","NO_INDEX","PROPERTY_SIZE","NAME_SIZE_OFFSET","MAX_NAME_LENGTH","TYPE_OFFSET","PREVIOUS_PROPERTY_OFFSET","NEXT_PROPERTY_OFFSET","CHILD_PROPERTY_OFFSET","START_BLOCK_OFFSET","SIZE_OFFSET","TYPE_ENUM","DIRECTORY","DOCUMENT","ROOT","FIELD","PREFIX","ATTACHMENT","RECIPIENT","NAME_MAPPING","CLASS_MAPPING","ATTACHMENT_DATA","TYPE_MAPPING","DIR_TYPE","INNER_MSG","arraysEqual","a","b","length","i","data","result","Array","isMSGFile","ds","seek","readInt8Array","getBlockOffsetAt","msgData","offset","bigBlockSize","getBlockAt","startOffset","readInt32Array","bigBlockLength","getNextBlockInner","blockOffsetData","currentBlock","Math","floor","currentBlockIndex","startBlockOffset","getNextBlock","batData","getNextBlockSmall","sbatData","parseMsgData","headerData","xbatCount","xbatData","propertyData","fieldsData","readByte","xBlockLength","batCount","readInt","propertyStart","sbatStart","sbatCount","xbatStart","batCountInHeader","maxBatsInHeader","min","readInt32","startIndex","push","batCountTotal","remainingBlocks","nextBlockAt","xBatBlock","blocksToProcess","j","blockStartAt","props","currentOffset","convertBlockToProperties","createPropertyHierarchy","convertName","nameLength","readShort","readStringAt","convertProperty","index","type","name","previousProperty","nextProperty","childProperty","startBlock","sizeBlock","propertyBlockOffset","propertyCount","propertyOffset","propertyType","nodeProperty","children","currentIndex","shift","current","fields","attachments","recipients","fieldsDataDir","dirProperty","fieldsDataDirInner","indexOf","fieldsDataDocument","attachmentField","recipientField","childFieldType","getFieldType","innerMsgContent","documentProperty","value","substring","toLowerCase","fieldClass","fieldType","fieldName","getFieldValue","fieldProperty","extractorFieldValue","sbat","extractDataViaSbat","dataTypeExtractor","chain","getChainByBlockSmall","readDataByBlockSmall","readChainDataByBlockSmall","dataType","extractBatString","blockStartOffset","bigBlockOffset","blockSize","readString","extractBatUnicode","readUCS2String","extractBatBinary","toReadLength","readUint8Array","bat","extractDataViaBat","extractSbatString","extractSbatUnicode","extractSbatBinary","byteOffset","bigBlockNumber","rootProp","nextBlock","resultData","Int8Array","idx","binary","localDs","LITTLE_ENDIAN","blockChain","nextBlockSmall","valueExtractor","extractor","arrayBuffer","prototype","getFileData","error","fileData","getAttachment","attach","attachData","dataId","fieldData","fileName","content"],"sources":["D:/sumit/hfc/wrm/node_modules/wl-msg-reader/lib/msg.reader.js"],"sourcesContent":["/* Copyright 2016 Yury Karpovich\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n MSG Reader\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['./DataStream'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(require('./DataStream'));\n    } else {\n        // Browser globals (root is window)\n        root.MSGReader = factory(root.DataStream);\n    }\n}(this, function (DataStream) {\n\n  // constants\n  var CONST = {\n    FILE_HEADER: uInt2int([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),\n    MSG: {\n      UNUSED_BLOCK: -1,\n      END_OF_CHAIN: -2,\n\n      S_BIG_BLOCK_SIZE: 0x0200,\n      S_BIG_BLOCK_MARK: 9,\n\n      L_BIG_BLOCK_SIZE: 0x1000,\n      L_BIG_BLOCK_MARK: 12,\n\n      SMALL_BLOCK_SIZE: 0x0040,\n      BIG_BLOCK_MIN_DOC_SIZE: 0x1000,\n      HEADER: {\n        PROPERTY_START_OFFSET: 0x30,\n\n        BAT_START_OFFSET: 0x4c,\n        BAT_COUNT_OFFSET: 0x2C,\n\n        SBAT_START_OFFSET: 0x3C,\n        SBAT_COUNT_OFFSET: 0x40,\n\n        XBAT_START_OFFSET: 0x44,\n        XBAT_COUNT_OFFSET: 0x48\n      },\n      PROP: {\n        NO_INDEX: -1,\n        PROPERTY_SIZE: 0x0080,\n\n        NAME_SIZE_OFFSET: 0x40,\n        MAX_NAME_LENGTH: (/*NAME_SIZE_OFFSET*/0x40 / 2) - 1,\n        TYPE_OFFSET: 0x42,\n        PREVIOUS_PROPERTY_OFFSET: 0x44,\n        NEXT_PROPERTY_OFFSET: 0x48,\n        CHILD_PROPERTY_OFFSET: 0x4C,\n        START_BLOCK_OFFSET: 0x74,\n        SIZE_OFFSET: 0x78,\n        TYPE_ENUM: {\n          DIRECTORY: 1,\n          DOCUMENT: 2,\n          ROOT: 5\n        }\n      },\n      FIELD: {\n        PREFIX: {\n          ATTACHMENT: '__attach_version1.0',\n          RECIPIENT: '__recip_version1.0',\n          DOCUMENT: '__substg1.'\n        },\n        // example (use fields as needed)\n        NAME_MAPPING: {\n          // email specific\n          '0037': 'subject',\n          '0c1a': 'senderName',\n          '5d02': 'senderEmail',\n          '1000': 'body',\n          '007d': 'headers',\n          // attachment specific\n          '3703': 'extension',\n          '3704': 'fileNameShort',\n          '3707': 'fileName',\n          '3712': 'pidContentId',\n          // recipient specific\n          '3001': 'name',\n          '39fe': 'email'\n        },\n        CLASS_MAPPING: {\n          ATTACHMENT_DATA: '3701'\n        },\n        TYPE_MAPPING: {\n          '001e': 'string',\n          '001f': 'unicode',\n          '0102': 'binary'\n        },\n        DIR_TYPE: {\n          INNER_MSG: '000d'\n        }\n      }\n    }\n  };\n\n  // unit utils\n  function arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length != b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  function uInt2int(data) {\n    var result = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      result[i] = data[i] << 24 >> 24;\n    }\n    return result;\n  }\n\n  // MSG Reader implementation\n\n  // check MSG file header\n  function isMSGFile(ds) {\n    ds.seek(0);\n    return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));\n  }\n\n  // FAT utils\n  function getBlockOffsetAt(msgData, offset) {\n    return (offset + 1) * msgData.bigBlockSize;\n  }\n\n  function getBlockAt(ds, msgData, offset) {\n    var startOffset = getBlockOffsetAt(msgData, offset);\n    ds.seek(startOffset);\n    return ds.readInt32Array(msgData.bigBlockLength);\n  }\n\n  function getNextBlockInner(ds, msgData, offset, blockOffsetData) {\n    var currentBlock = Math.floor(offset / msgData.bigBlockLength);\n    var currentBlockIndex = offset % msgData.bigBlockLength;\n\n    var startBlockOffset = blockOffsetData[currentBlock];\n\n    return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];\n  }\n\n  function getNextBlock(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.batData);\n  }\n\n  function getNextBlockSmall(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.sbatData);\n  }\n\n  // convert binary data to dictionary\n  function parseMsgData(ds) {\n    var msgData = headerData(ds);\n    msgData.batData = batData(ds, msgData);\n    msgData.sbatData = sbatData(ds, msgData);\n    if (msgData.xbatCount > 0) {\n      xbatData(ds, msgData);\n    }\n    msgData.propertyData = propertyData(ds, msgData);\n    msgData.fieldsData = fieldsData(ds, msgData);\n\n    return msgData;\n  }\n\n  // extract header data\n  function headerData(ds) {\n    var headerData = {};\n\n    // system data\n    headerData.bigBlockSize =\n      ds.readByte(/*const position*/30) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;\n    headerData.bigBlockLength = headerData.bigBlockSize / 4;\n    headerData.xBlockLength = headerData.bigBlockLength - 1;\n\n    // header data\n    headerData.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);\n    headerData.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);\n    headerData.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);\n    headerData.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);\n    headerData.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);\n    headerData.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);\n\n    return headerData;\n  }\n\n  function batCountInHeader(msgData) {\n    var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;\n    return Math.min(msgData.batCount, maxBatsInHeader);\n  }\n\n  function batData(ds, msgData) {\n    var result = new Array(batCountInHeader(msgData));\n    ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);\n    for (var i = 0; i < result.length; i++) {\n      result[i] = ds.readInt32()\n    }\n    return result;\n  }\n\n  function sbatData(ds, msgData) {\n    var result = [];\n    var startIndex = msgData.sbatStart;\n\n    for (var i = 0; i < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i++) {\n      result.push(startIndex);\n      startIndex = getNextBlock(ds, msgData, startIndex);\n    }\n    return result;\n  }\n\n  function xbatData(ds, msgData) {\n    var batCount = batCountInHeader(msgData);\n    var batCountTotal = msgData.batCount;\n    var remainingBlocks = batCountTotal - batCount;\n\n    var nextBlockAt = msgData.xbatStart;\n    for (var i = 0; i < msgData.xbatCount; i++) {\n      var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);\n      nextBlockAt = xBatBlock[msgData.xBlockLength];\n\n      var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);\n      for (var j = 0; j < blocksToProcess; j++) {\n        var blockStartAt = xBatBlock[j];\n        if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {\n          break;\n        }\n        msgData.batData.push(blockStartAt);\n      }\n      remainingBlocks -= blocksToProcess;\n    }\n  }\n\n  // extract property data and property hierarchy\n  function propertyData(ds, msgData) {\n    var props = [];\n\n    var currentOffset = msgData.propertyStart;\n\n    while (currentOffset != CONST.MSG.END_OF_CHAIN) {\n      convertBlockToProperties(ds, msgData, currentOffset, props);\n      currentOffset = getNextBlock(ds, msgData, currentOffset);\n    }\n    createPropertyHierarchy(props, /*property with index 0 (zero) always as root*/props[0]);\n    return props;\n  }\n\n  function convertName(ds, offset) {\n    var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);\n    if (nameLength < 1) {\n      return '';\n    } else {\n      return ds.readStringAt(offset, nameLength / 2);\n    }\n  }\n\n  function convertProperty(ds, index, offset) {\n    return {\n      index: index,\n      type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),\n      name: convertName(ds, offset),\n      // hierarchy\n      previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),\n      nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),\n      childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),\n      // data offset\n      startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),\n      sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)\n    };\n  }\n\n  function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {\n\n    var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;\n    var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);\n\n    for (var i = 0; i < propertyCount; i++) {\n      var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);\n      switch (propertyType) {\n        case CONST.MSG.PROP.TYPE_ENUM.ROOT:\n        case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:\n        case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:\n          props.push(convertProperty(ds, props.length, propertyOffset));\n          break;\n        default:\n          /* unknown property types */\n          props.push(null);\n      }\n\n      propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;\n    }\n  }\n\n  function createPropertyHierarchy(props, nodeProperty) {\n\n    if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {\n      return;\n    }\n    nodeProperty.children = [];\n\n    var children = [nodeProperty.childProperty];\n    while (children.length != 0) {\n      var currentIndex = children.shift();\n      var current = props[currentIndex];\n      if (current == null) {\n        continue;\n      }\n      nodeProperty.children.push(currentIndex);\n\n      if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n        createPropertyHierarchy(props, current);\n      }\n      if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.previousProperty);\n      }\n      if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.nextProperty);\n      }\n    }\n  }\n\n  // extract real fields\n  function fieldsData(ds, msgData) {\n    var fields = {\n      attachments: [],\n      recipients: []\n    };\n    fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);\n    return fields;\n  }\n\n  function fieldsDataDir(ds, msgData, dirProperty, fields) {\n\n    if (dirProperty.children && dirProperty.children.length > 0) {\n      for (var i = 0; i < dirProperty.children.length; i++) {\n        var childProperty = msgData.propertyData[dirProperty.children[i]];\n\n        if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n          fieldsDataDirInner(ds, msgData, childProperty, fields)\n        } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT\n          && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {\n          fieldsDataDocument(ds, msgData, childProperty, fields);\n        }\n      }\n    }\n  }\n\n  function fieldsDataDirInner(ds, msgData, dirProperty, fields) {\n    if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {\n\n      // attachment\n      var attachmentField = {};\n      fields.attachments.push(attachmentField);\n      fieldsDataDir(ds, msgData, dirProperty, attachmentField);\n    } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {\n\n      // recipient\n      var recipientField = {};\n      fields.recipients.push(recipientField);\n      fieldsDataDir(ds, msgData, dirProperty, recipientField);\n    } else {\n\n      // other dir\n      var childFieldType = getFieldType(dirProperty);\n      if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {\n        fieldsDataDir(ds, msgData, dirProperty, fields);\n      } else {\n        // MSG as attachment currently isn't supported\n        fields.innerMsgContent = true;\n      }\n    }\n  }\n\n  function fieldsDataDocument(ds, msgData, documentProperty, fields) {\n    var value = documentProperty.name.substring(12).toLowerCase();\n    var fieldClass = value.substring(0, 4);\n    var fieldType = value.substring(4, 8);\n\n    var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];\n\n    if (fieldName) {\n      fields[fieldName] = getFieldValue(ds, msgData, documentProperty, fieldType);\n    }\n    if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {\n\n      // attachment specific info\n      fields['dataId'] = documentProperty.index;\n      fields['contentLength'] = documentProperty.sizeBlock;\n    }\n  }\n\n  function getFieldType(fieldProperty) {\n    var value = fieldProperty.name.substring(12).toLowerCase();\n    return value.substring(4, 8);\n  }\n\n  // extractor structure to manage bat/sbat block types and different data types\n  var extractorFieldValue = {\n    sbat: {\n      'extractor': function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var chain = getChainByBlockSmall(ds, msgData, fieldProperty);\n        if (chain.length == 1) {\n          return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);\n        } else if (chain.length > 1) {\n          return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);\n        }\n        return null;\n      },\n      dataType: {\n        'string': function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readString(blockSize);\n        },\n        'unicode': function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readUCS2String(blockSize / 2);\n        },\n        'binary': function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);\n          return ds.readUint8Array(toReadLength);\n        }\n      }\n    },\n    bat: {\n      'extractor': function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);\n        ds.seek(offset);\n        return dataTypeExtractor(ds, fieldProperty);\n      },\n      dataType: {\n        'string': function extractSbatString(ds, fieldProperty) {\n          return ds.readString(fieldProperty.sizeBlock);\n        },\n        'unicode': function extractSbatUnicode(ds, fieldProperty) {\n          return ds.readUCS2String(fieldProperty.sizeBlock / 2);\n        },\n        'binary': function extractSbatBinary(ds, fieldProperty) {\n          return ds.readUint8Array(fieldProperty.sizeBlock);\n        }\n      }\n    }\n  };\n\n  function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {\n    var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;\n    var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);\n    var bigBlockOffset = byteOffset % msgData.bigBlockSize;\n\n    var rootProp = msgData.propertyData[0];\n\n    var nextBlock = rootProp.startBlock;\n    for (var i = 0; i < bigBlockNumber; i++) {\n      nextBlock = getNextBlock(ds, msgData, nextBlock);\n    }\n    var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);\n\n    return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);\n  }\n\n  function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {\n    var resultData = new Int8Array(fieldProperty.sizeBlock);\n\n    for (var i = 0, idx = 0; i < chain.length; i++) {\n      var data = readDataByBlockSmall(ds, msgData, chain[i], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);\n      for (var j = 0; j < data.length; j++) {\n        resultData[idx++] = data[j];\n      }\n    }\n    var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);\n    return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);\n  }\n\n  function getChainByBlockSmall(ds, msgData, fieldProperty) {\n    var blockChain = [];\n    var nextBlockSmall = fieldProperty.startBlock;\n    while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {\n      blockChain.push(nextBlockSmall);\n      nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);\n    }\n    return blockChain;\n  }\n\n  function getFieldValue(ds, msgData, fieldProperty, type) {\n    var value = null;\n\n    var valueExtractor =\n      fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;\n    var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];\n\n    if (dataTypeExtractor) {\n      value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);\n    }\n    return value;\n  }\n\n  // MSG Reader\n  var MSGReader = function (arrayBuffer) {\n    this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n  };\n\n  MSGReader.prototype = {\n    /**\n     Converts bytes to fields information\n\n     @return {Object} The fields data for MSG file\n     */\n    getFileData: function () {\n      if (!isMSGFile(this.ds)) {\n        return {error: 'Unsupported file type!'};\n      }\n      if (this.fileData == null) {\n        this.fileData = parseMsgData(this.ds);\n      }\n      return this.fileData.fieldsData;\n    },\n    /**\n     Reads an attachment content by key/ID\n\n     @return {Object} The attachment for specific attachment key\n     */\n    getAttachment: function (attach) {\n      var attachData = typeof attach === 'number' ? this.fileData.fieldsData.attachments[attach] : attach;\n      var fieldProperty = this.fileData.propertyData[attachData.dataId];\n      var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));\n\n      return {fileName: attachData.fileName, content: fieldData};\n    }\n  };\n\n  return MSGReader;\n\n}));"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC,WAAUA,IAAI,EAAEC,OAAO,EAAE;EACtB,IAAI,OAAOC,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,EAAE;IAC5C;IACAD,MAAM,CAAC,CAAC,cAAc,CAAC,EAAED,OAAO,CAAC;EACrC,CAAC,MAAM,IAAI,OAAOG,OAAO,KAAK,QAAQ,EAAE;IACpC;IACAC,MAAM,CAACD,OAAO,GAAGH,OAAO,CAACK,OAAO,CAAC,cAAc,CAAC,CAAC;EACrD,CAAC,MAAM;IACH;IACAN,IAAI,CAACO,SAAS,GAAGN,OAAO,CAACD,IAAI,CAACQ,UAAU,CAAC;EAC7C;AACJ,CAAC,EAAC,IAAI,EAAE,UAAUA,UAAU,EAAE;EAE5B;EACA,IAAIC,KAAK,GAAG;IACVC,WAAW,EAAEC,QAAQ,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IACvEC,GAAG,EAAE;MACHC,YAAY,EAAE,CAAC,CAAC;MAChBC,YAAY,EAAE,CAAC,CAAC;MAEhBC,gBAAgB,EAAE,MAAM;MACxBC,gBAAgB,EAAE,CAAC;MAEnBC,gBAAgB,EAAE,MAAM;MACxBC,gBAAgB,EAAE,EAAE;MAEpBC,gBAAgB,EAAE,MAAM;MACxBC,sBAAsB,EAAE,MAAM;MAC9BC,MAAM,EAAE;QACNC,qBAAqB,EAAE,IAAI;QAE3BC,gBAAgB,EAAE,IAAI;QACtBC,gBAAgB,EAAE,IAAI;QAEtBC,iBAAiB,EAAE,IAAI;QACvBC,iBAAiB,EAAE,IAAI;QAEvBC,iBAAiB,EAAE,IAAI;QACvBC,iBAAiB,EAAE;MACrB,CAAC;MACDC,IAAI,EAAE;QACJC,QAAQ,EAAE,CAAC,CAAC;QACZC,aAAa,EAAE,MAAM;QAErBC,gBAAgB,EAAE,IAAI;QACtBC,eAAe,EAAE,EAAC,oBAAoB,IAAI,GAAG,CAAC,IAAI,CAAC;QACnDC,WAAW,EAAE,IAAI;QACjBC,wBAAwB,EAAE,IAAI;QAC9BC,oBAAoB,EAAE,IAAI;QAC1BC,qBAAqB,EAAE,IAAI;QAC3BC,kBAAkB,EAAE,IAAI;QACxBC,WAAW,EAAE,IAAI;QACjBC,SAAS,EAAE;UACTC,SAAS,EAAE,CAAC;UACZC,QAAQ,EAAE,CAAC;UACXC,IAAI,EAAE;QACR;MACF,CAAC;MACDC,KAAK,EAAE;QACLC,MAAM,EAAE;UACNC,UAAU,EAAE,qBAAqB;UACjCC,SAAS,EAAE,oBAAoB;UAC/BL,QAAQ,EAAE;QACZ,CAAC;QACD;QACAM,YAAY,EAAE;UACZ;UACA,MAAM,EAAE,SAAS;UACjB,MAAM,EAAE,YAAY;UACpB,MAAM,EAAE,aAAa;UACrB,MAAM,EAAE,MAAM;UACd,MAAM,EAAE,SAAS;UACjB;UACA,MAAM,EAAE,WAAW;UACnB,MAAM,EAAE,eAAe;UACvB,MAAM,EAAE,UAAU;UAClB,MAAM,EAAE,cAAc;UACtB;UACA,MAAM,EAAE,MAAM;UACd,MAAM,EAAE;QACV,CAAC;QACDC,aAAa,EAAE;UACbC,eAAe,EAAE;QACnB,CAAC;QACDC,YAAY,EAAE;UACZ,MAAM,EAAE,QAAQ;UAChB,MAAM,EAAE,SAAS;UACjB,MAAM,EAAE;QACV,CAAC;QACDC,QAAQ,EAAE;UACRC,SAAS,EAAE;QACb;MACF;IACF;EACF,CAAC;;EAED;EACA,SAASC,WAAWA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACzB,IAAID,CAAC,KAAKC,CAAC,EAAE,OAAO,IAAI;IACxB,IAAID,CAAC,IAAI,IAAI,IAAIC,CAAC,IAAI,IAAI,EAAE,OAAO,KAAK;IACxC,IAAID,CAAC,CAACE,MAAM,IAAID,CAAC,CAACC,MAAM,EAAE,OAAO,KAAK;IAEtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,CAAC,CAACE,MAAM,EAAEC,CAAC,EAAE,EAAE;MACjC,IAAIH,CAAC,CAACG,CAAC,CAAC,KAAKF,CAAC,CAACE,CAAC,CAAC,EAAE,OAAO,KAAK;IACjC;IACA,OAAO,IAAI;EACb;EAEA,SAAS/C,QAAQA,CAACgD,IAAI,EAAE;IACtB,IAAIC,MAAM,GAAG,IAAIC,KAAK,CAACF,IAAI,CAACF,MAAM,CAAC;IACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACF,MAAM,EAAEC,CAAC,EAAE,EAAE;MACpCE,MAAM,CAACF,CAAC,CAAC,GAAGC,IAAI,CAACD,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE;IACjC;IACA,OAAOE,MAAM;EACf;;EAEA;;EAEA;EACA,SAASE,SAASA,CAACC,EAAE,EAAE;IACrBA,EAAE,CAACC,IAAI,CAAC,CAAC,CAAC;IACV,OAAOV,WAAW,CAAC7C,KAAK,CAACC,WAAW,EAAEqD,EAAE,CAACE,aAAa,CAACxD,KAAK,CAACC,WAAW,CAAC+C,MAAM,CAAC,CAAC;EACnF;;EAEA;EACA,SAASS,gBAAgBA,CAACC,OAAO,EAAEC,MAAM,EAAE;IACzC,OAAO,CAACA,MAAM,GAAG,CAAC,IAAID,OAAO,CAACE,YAAY;EAC5C;EAEA,SAASC,UAAUA,CAACP,EAAE,EAAEI,OAAO,EAAEC,MAAM,EAAE;IACvC,IAAIG,WAAW,GAAGL,gBAAgB,CAACC,OAAO,EAAEC,MAAM,CAAC;IACnDL,EAAE,CAACC,IAAI,CAACO,WAAW,CAAC;IACpB,OAAOR,EAAE,CAACS,cAAc,CAACL,OAAO,CAACM,cAAc,CAAC;EAClD;EAEA,SAASC,iBAAiBA,CAACX,EAAE,EAAEI,OAAO,EAAEC,MAAM,EAAEO,eAAe,EAAE;IAC/D,IAAIC,YAAY,GAAGC,IAAI,CAACC,KAAK,CAACV,MAAM,GAAGD,OAAO,CAACM,cAAc,CAAC;IAC9D,IAAIM,iBAAiB,GAAGX,MAAM,GAAGD,OAAO,CAACM,cAAc;IAEvD,IAAIO,gBAAgB,GAAGL,eAAe,CAACC,YAAY,CAAC;IAEpD,OAAON,UAAU,CAACP,EAAE,EAAEI,OAAO,EAAEa,gBAAgB,CAAC,CAACD,iBAAiB,CAAC;EACrE;EAEA,SAASE,YAAYA,CAAClB,EAAE,EAAEI,OAAO,EAAEC,MAAM,EAAE;IACzC,OAAOM,iBAAiB,CAACX,EAAE,EAAEI,OAAO,EAAEC,MAAM,EAAED,OAAO,CAACe,OAAO,CAAC;EAChE;EAEA,SAASC,iBAAiBA,CAACpB,EAAE,EAAEI,OAAO,EAAEC,MAAM,EAAE;IAC9C,OAAOM,iBAAiB,CAACX,EAAE,EAAEI,OAAO,EAAEC,MAAM,EAAED,OAAO,CAACiB,QAAQ,CAAC;EACjE;;EAEA;EACA,SAASC,YAAYA,CAACtB,EAAE,EAAE;IACxB,IAAII,OAAO,GAAGmB,UAAU,CAACvB,EAAE,CAAC;IAC5BI,OAAO,CAACe,OAAO,GAAGA,OAAO,CAACnB,EAAE,EAAEI,OAAO,CAAC;IACtCA,OAAO,CAACiB,QAAQ,GAAGA,QAAQ,CAACrB,EAAE,EAAEI,OAAO,CAAC;IACxC,IAAIA,OAAO,CAACoB,SAAS,GAAG,CAAC,EAAE;MACzBC,QAAQ,CAACzB,EAAE,EAAEI,OAAO,CAAC;IACvB;IACAA,OAAO,CAACsB,YAAY,GAAGA,YAAY,CAAC1B,EAAE,EAAEI,OAAO,CAAC;IAChDA,OAAO,CAACuB,UAAU,GAAGA,UAAU,CAAC3B,EAAE,EAAEI,OAAO,CAAC;IAE5C,OAAOA,OAAO;EAChB;;EAEA;EACA,SAASmB,UAAUA,CAACvB,EAAE,EAAE;IACtB,IAAIuB,UAAU,GAAG,CAAC,CAAC;;IAEnB;IACAA,UAAU,CAACjB,YAAY,GACrBN,EAAE,CAAC4B,QAAQ,EAAC,kBAAkB,EAAE,CAAC,IAAIlF,KAAK,CAACG,GAAG,CAACM,gBAAgB,GAAGT,KAAK,CAACG,GAAG,CAACK,gBAAgB,GAAGR,KAAK,CAACG,GAAG,CAACG,gBAAgB;IAC3HuE,UAAU,CAACb,cAAc,GAAGa,UAAU,CAACjB,YAAY,GAAG,CAAC;IACvDiB,UAAU,CAACM,YAAY,GAAGN,UAAU,CAACb,cAAc,GAAG,CAAC;;IAEvD;IACAa,UAAU,CAACO,QAAQ,GAAG9B,EAAE,CAAC+B,OAAO,CAACrF,KAAK,CAACG,GAAG,CAACS,MAAM,CAACG,gBAAgB,CAAC;IACnE8D,UAAU,CAACS,aAAa,GAAGhC,EAAE,CAAC+B,OAAO,CAACrF,KAAK,CAACG,GAAG,CAACS,MAAM,CAACC,qBAAqB,CAAC;IAC7EgE,UAAU,CAACU,SAAS,GAAGjC,EAAE,CAAC+B,OAAO,CAACrF,KAAK,CAACG,GAAG,CAACS,MAAM,CAACI,iBAAiB,CAAC;IACrE6D,UAAU,CAACW,SAAS,GAAGlC,EAAE,CAAC+B,OAAO,CAACrF,KAAK,CAACG,GAAG,CAACS,MAAM,CAACK,iBAAiB,CAAC;IACrE4D,UAAU,CAACY,SAAS,GAAGnC,EAAE,CAAC+B,OAAO,CAACrF,KAAK,CAACG,GAAG,CAACS,MAAM,CAACM,iBAAiB,CAAC;IACrE2D,UAAU,CAACC,SAAS,GAAGxB,EAAE,CAAC+B,OAAO,CAACrF,KAAK,CAACG,GAAG,CAACS,MAAM,CAACO,iBAAiB,CAAC;IAErE,OAAO0D,UAAU;EACnB;EAEA,SAASa,gBAAgBA,CAAChC,OAAO,EAAE;IACjC,IAAIiC,eAAe,GAAG,CAAC3F,KAAK,CAACG,GAAG,CAACG,gBAAgB,GAAGN,KAAK,CAACG,GAAG,CAACS,MAAM,CAACE,gBAAgB,IAAI,CAAC;IAC1F,OAAOsD,IAAI,CAACwB,GAAG,CAAClC,OAAO,CAAC0B,QAAQ,EAAEO,eAAe,CAAC;EACpD;EAEA,SAASlB,OAAOA,CAACnB,EAAE,EAAEI,OAAO,EAAE;IAC5B,IAAIP,MAAM,GAAG,IAAIC,KAAK,CAACsC,gBAAgB,CAAChC,OAAO,CAAC,CAAC;IACjDJ,EAAE,CAACC,IAAI,CAACvD,KAAK,CAACG,GAAG,CAACS,MAAM,CAACE,gBAAgB,CAAC;IAC1C,KAAK,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACH,MAAM,EAAEC,CAAC,EAAE,EAAE;MACtCE,MAAM,CAACF,CAAC,CAAC,GAAGK,EAAE,CAACuC,SAAS,CAAC,CAAC;IAC5B;IACA,OAAO1C,MAAM;EACf;EAEA,SAASwB,QAAQA,CAACrB,EAAE,EAAEI,OAAO,EAAE;IAC7B,IAAIP,MAAM,GAAG,EAAE;IACf,IAAI2C,UAAU,GAAGpC,OAAO,CAAC6B,SAAS;IAElC,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,OAAO,CAAC8B,SAAS,IAAIM,UAAU,IAAI9F,KAAK,CAACG,GAAG,CAACE,YAAY,EAAE4C,CAAC,EAAE,EAAE;MAClFE,MAAM,CAAC4C,IAAI,CAACD,UAAU,CAAC;MACvBA,UAAU,GAAGtB,YAAY,CAAClB,EAAE,EAAEI,OAAO,EAAEoC,UAAU,CAAC;IACpD;IACA,OAAO3C,MAAM;EACf;EAEA,SAAS4B,QAAQA,CAACzB,EAAE,EAAEI,OAAO,EAAE;IAC7B,IAAI0B,QAAQ,GAAGM,gBAAgB,CAAChC,OAAO,CAAC;IACxC,IAAIsC,aAAa,GAAGtC,OAAO,CAAC0B,QAAQ;IACpC,IAAIa,eAAe,GAAGD,aAAa,GAAGZ,QAAQ;IAE9C,IAAIc,WAAW,GAAGxC,OAAO,CAAC+B,SAAS;IACnC,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,OAAO,CAACoB,SAAS,EAAE7B,CAAC,EAAE,EAAE;MAC1C,IAAIkD,SAAS,GAAGtC,UAAU,CAACP,EAAE,EAAEI,OAAO,EAAEwC,WAAW,CAAC;MACpDA,WAAW,GAAGC,SAAS,CAACzC,OAAO,CAACyB,YAAY,CAAC;MAE7C,IAAIiB,eAAe,GAAGhC,IAAI,CAACwB,GAAG,CAACK,eAAe,EAAEvC,OAAO,CAACyB,YAAY,CAAC;MACrE,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,eAAe,EAAEC,CAAC,EAAE,EAAE;QACxC,IAAIC,YAAY,GAAGH,SAAS,CAACE,CAAC,CAAC;QAC/B,IAAIC,YAAY,IAAItG,KAAK,CAACG,GAAG,CAACC,YAAY,IAAIkG,YAAY,IAAItG,KAAK,CAACG,GAAG,CAACE,YAAY,EAAE;UACpF;QACF;QACAqD,OAAO,CAACe,OAAO,CAACsB,IAAI,CAACO,YAAY,CAAC;MACpC;MACAL,eAAe,IAAIG,eAAe;IACpC;EACF;;EAEA;EACA,SAASpB,YAAYA,CAAC1B,EAAE,EAAEI,OAAO,EAAE;IACjC,IAAI6C,KAAK,GAAG,EAAE;IAEd,IAAIC,aAAa,GAAG9C,OAAO,CAAC4B,aAAa;IAEzC,OAAOkB,aAAa,IAAIxG,KAAK,CAACG,GAAG,CAACE,YAAY,EAAE;MAC9CoG,wBAAwB,CAACnD,EAAE,EAAEI,OAAO,EAAE8C,aAAa,EAAED,KAAK,CAAC;MAC3DC,aAAa,GAAGhC,YAAY,CAAClB,EAAE,EAAEI,OAAO,EAAE8C,aAAa,CAAC;IAC1D;IACAE,uBAAuB,CAACH,KAAK,EAAE,+CAA+CA,KAAK,CAAC,CAAC,CAAC,CAAC;IACvF,OAAOA,KAAK;EACd;EAEA,SAASI,WAAWA,CAACrD,EAAE,EAAEK,MAAM,EAAE;IAC/B,IAAIiD,UAAU,GAAGtD,EAAE,CAACuD,SAAS,CAAClD,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACG,gBAAgB,CAAC;IACvE,IAAIqF,UAAU,GAAG,CAAC,EAAE;MAClB,OAAO,EAAE;IACX,CAAC,MAAM;MACL,OAAOtD,EAAE,CAACwD,YAAY,CAACnD,MAAM,EAAEiD,UAAU,GAAG,CAAC,CAAC;IAChD;EACF;EAEA,SAASG,eAAeA,CAACzD,EAAE,EAAE0D,KAAK,EAAErD,MAAM,EAAE;IAC1C,OAAO;MACLqD,KAAK,EAAEA,KAAK;MACZC,IAAI,EAAE3D,EAAE,CAAC4B,QAAQ,CAACvB,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACK,WAAW,CAAC;MACtDyF,IAAI,EAAEP,WAAW,CAACrD,EAAE,EAAEK,MAAM,CAAC;MAC7B;MACAwD,gBAAgB,EAAE7D,EAAE,CAAC+B,OAAO,CAAC1B,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACM,wBAAwB,CAAC;MAC9E0F,YAAY,EAAE9D,EAAE,CAAC+B,OAAO,CAAC1B,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACO,oBAAoB,CAAC;MACtE0F,aAAa,EAAE/D,EAAE,CAAC+B,OAAO,CAAC1B,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACQ,qBAAqB,CAAC;MACxE;MACA0F,UAAU,EAAEhE,EAAE,CAAC+B,OAAO,CAAC1B,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACS,kBAAkB,CAAC;MAClE0F,SAAS,EAAEjE,EAAE,CAAC+B,OAAO,CAAC1B,MAAM,GAAG3D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACU,WAAW;IAC3D,CAAC;EACH;EAEA,SAAS2E,wBAAwBA,CAACnD,EAAE,EAAEI,OAAO,EAAE8D,mBAAmB,EAAEjB,KAAK,EAAE;IAEzE,IAAIkB,aAAa,GAAG/D,OAAO,CAACE,YAAY,GAAG5D,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACE,aAAa;IACvE,IAAIoG,cAAc,GAAGjE,gBAAgB,CAACC,OAAO,EAAE8D,mBAAmB,CAAC;IAEnE,KAAK,IAAIvE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,aAAa,EAAExE,CAAC,EAAE,EAAE;MACtC,IAAI0E,YAAY,GAAGrE,EAAE,CAAC4B,QAAQ,CAACwC,cAAc,GAAG1H,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACK,WAAW,CAAC;MAC3E,QAAQkG,YAAY;QAClB,KAAK3H,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACW,SAAS,CAACG,IAAI;QAClC,KAAKlC,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACW,SAAS,CAACC,SAAS;QACvC,KAAKhC,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACW,SAAS,CAACE,QAAQ;UACpCsE,KAAK,CAACR,IAAI,CAACgB,eAAe,CAACzD,EAAE,EAAEiD,KAAK,CAACvD,MAAM,EAAE0E,cAAc,CAAC,CAAC;UAC7D;QACF;UACE;UACAnB,KAAK,CAACR,IAAI,CAAC,IAAI,CAAC;MACpB;MAEA2B,cAAc,IAAI1H,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACE,aAAa;IAChD;EACF;EAEA,SAASoF,uBAAuBA,CAACH,KAAK,EAAEqB,YAAY,EAAE;IAEpD,IAAIA,YAAY,CAACP,aAAa,IAAIrH,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACC,QAAQ,EAAE;MACzD;IACF;IACAuG,YAAY,CAACC,QAAQ,GAAG,EAAE;IAE1B,IAAIA,QAAQ,GAAG,CAACD,YAAY,CAACP,aAAa,CAAC;IAC3C,OAAOQ,QAAQ,CAAC7E,MAAM,IAAI,CAAC,EAAE;MAC3B,IAAI8E,YAAY,GAAGD,QAAQ,CAACE,KAAK,CAAC,CAAC;MACnC,IAAIC,OAAO,GAAGzB,KAAK,CAACuB,YAAY,CAAC;MACjC,IAAIE,OAAO,IAAI,IAAI,EAAE;QACnB;MACF;MACAJ,YAAY,CAACC,QAAQ,CAAC9B,IAAI,CAAC+B,YAAY,CAAC;MAExC,IAAIE,OAAO,CAACf,IAAI,IAAIjH,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACW,SAAS,CAACC,SAAS,EAAE;QACtD0E,uBAAuB,CAACH,KAAK,EAAEyB,OAAO,CAAC;MACzC;MACA,IAAIA,OAAO,CAACb,gBAAgB,IAAInH,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACC,QAAQ,EAAE;QACvDwG,QAAQ,CAAC9B,IAAI,CAACiC,OAAO,CAACb,gBAAgB,CAAC;MACzC;MACA,IAAIa,OAAO,CAACZ,YAAY,IAAIpH,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACC,QAAQ,EAAE;QACnDwG,QAAQ,CAAC9B,IAAI,CAACiC,OAAO,CAACZ,YAAY,CAAC;MACrC;IACF;EACF;;EAEA;EACA,SAASnC,UAAUA,CAAC3B,EAAE,EAAEI,OAAO,EAAE;IAC/B,IAAIuE,MAAM,GAAG;MACXC,WAAW,EAAE,EAAE;MACfC,UAAU,EAAE;IACd,CAAC;IACDC,aAAa,CAAC9E,EAAE,EAAEI,OAAO,EAAEA,OAAO,CAACsB,YAAY,CAAC,CAAC,CAAC,EAAEiD,MAAM,CAAC;IAC3D,OAAOA,MAAM;EACf;EAEA,SAASG,aAAaA,CAAC9E,EAAE,EAAEI,OAAO,EAAE2E,WAAW,EAAEJ,MAAM,EAAE;IAEvD,IAAII,WAAW,CAACR,QAAQ,IAAIQ,WAAW,CAACR,QAAQ,CAAC7E,MAAM,GAAG,CAAC,EAAE;MAC3D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoF,WAAW,CAACR,QAAQ,CAAC7E,MAAM,EAAEC,CAAC,EAAE,EAAE;QACpD,IAAIoE,aAAa,GAAG3D,OAAO,CAACsB,YAAY,CAACqD,WAAW,CAACR,QAAQ,CAAC5E,CAAC,CAAC,CAAC;QAEjE,IAAIoE,aAAa,CAACJ,IAAI,IAAIjH,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACW,SAAS,CAACC,SAAS,EAAE;UAC5DsG,kBAAkB,CAAChF,EAAE,EAAEI,OAAO,EAAE2D,aAAa,EAAEY,MAAM,CAAC;QACxD,CAAC,MAAM,IAAIZ,aAAa,CAACJ,IAAI,IAAIjH,KAAK,CAACG,GAAG,CAACiB,IAAI,CAACW,SAAS,CAACE,QAAQ,IAC7DoF,aAAa,CAACH,IAAI,CAACqB,OAAO,CAACvI,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACC,MAAM,CAACH,QAAQ,CAAC,IAAI,CAAC,EAAE;UACrEuG,kBAAkB,CAAClF,EAAE,EAAEI,OAAO,EAAE2D,aAAa,EAAEY,MAAM,CAAC;QACxD;MACF;IACF;EACF;EAEA,SAASK,kBAAkBA,CAAChF,EAAE,EAAEI,OAAO,EAAE2E,WAAW,EAAEJ,MAAM,EAAE;IAC5D,IAAII,WAAW,CAACnB,IAAI,CAACqB,OAAO,CAACvI,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACC,MAAM,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MAEpE;MACA,IAAIoG,eAAe,GAAG,CAAC,CAAC;MACxBR,MAAM,CAACC,WAAW,CAACnC,IAAI,CAAC0C,eAAe,CAAC;MACxCL,aAAa,CAAC9E,EAAE,EAAEI,OAAO,EAAE2E,WAAW,EAAEI,eAAe,CAAC;IAC1D,CAAC,MAAM,IAAIJ,WAAW,CAACnB,IAAI,CAACqB,OAAO,CAACvI,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACC,MAAM,CAACE,SAAS,CAAC,IAAI,CAAC,EAAE;MAE1E;MACA,IAAIoG,cAAc,GAAG,CAAC,CAAC;MACvBT,MAAM,CAACE,UAAU,CAACpC,IAAI,CAAC2C,cAAc,CAAC;MACtCN,aAAa,CAAC9E,EAAE,EAAEI,OAAO,EAAE2E,WAAW,EAAEK,cAAc,CAAC;IACzD,CAAC,MAAM;MAEL;MACA,IAAIC,cAAc,GAAGC,YAAY,CAACP,WAAW,CAAC;MAC9C,IAAIM,cAAc,IAAI3I,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACQ,QAAQ,CAACC,SAAS,EAAE;QACxDwF,aAAa,CAAC9E,EAAE,EAAEI,OAAO,EAAE2E,WAAW,EAAEJ,MAAM,CAAC;MACjD,CAAC,MAAM;QACL;QACAA,MAAM,CAACY,eAAe,GAAG,IAAI;MAC/B;IACF;EACF;EAEA,SAASL,kBAAkBA,CAAClF,EAAE,EAAEI,OAAO,EAAEoF,gBAAgB,EAAEb,MAAM,EAAE;IACjE,IAAIc,KAAK,GAAGD,gBAAgB,CAAC5B,IAAI,CAAC8B,SAAS,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;IAC7D,IAAIC,UAAU,GAAGH,KAAK,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;IACtC,IAAIG,SAAS,GAAGJ,KAAK,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;IAErC,IAAII,SAAS,GAAGpJ,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACI,YAAY,CAAC2G,UAAU,CAAC;IAExD,IAAIE,SAAS,EAAE;MACbnB,MAAM,CAACmB,SAAS,CAAC,GAAGC,aAAa,CAAC/F,EAAE,EAAEI,OAAO,EAAEoF,gBAAgB,EAAEK,SAAS,CAAC;IAC7E;IACA,IAAID,UAAU,IAAIlJ,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACK,aAAa,CAACC,eAAe,EAAE;MAE/D;MACAwF,MAAM,CAAC,QAAQ,CAAC,GAAGa,gBAAgB,CAAC9B,KAAK;MACzCiB,MAAM,CAAC,eAAe,CAAC,GAAGa,gBAAgB,CAACvB,SAAS;IACtD;EACF;EAEA,SAASqB,YAAYA,CAACU,aAAa,EAAE;IACnC,IAAIP,KAAK,GAAGO,aAAa,CAACpC,IAAI,CAAC8B,SAAS,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;IAC1D,OAAOF,KAAK,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;EAC9B;;EAEA;EACA,IAAIO,mBAAmB,GAAG;IACxBC,IAAI,EAAE;MACJ,WAAW,EAAE,SAASC,kBAAkBA,CAACnG,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAEI,iBAAiB,EAAE;QACtF,IAAIC,KAAK,GAAGC,oBAAoB,CAACtG,EAAE,EAAEI,OAAO,EAAE4F,aAAa,CAAC;QAC5D,IAAIK,KAAK,CAAC3G,MAAM,IAAI,CAAC,EAAE;UACrB,OAAO6G,oBAAoB,CAACvG,EAAE,EAAEI,OAAO,EAAE4F,aAAa,CAAChC,UAAU,EAAEgC,aAAa,CAAC/B,SAAS,EAAEmC,iBAAiB,CAAC;QAChH,CAAC,MAAM,IAAIC,KAAK,CAAC3G,MAAM,GAAG,CAAC,EAAE;UAC3B,OAAO8G,yBAAyB,CAACxG,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAEK,KAAK,EAAED,iBAAiB,CAAC;QACxF;QACA,OAAO,IAAI;MACb,CAAC;MACDK,QAAQ,EAAE;QACR,QAAQ,EAAE,SAASC,gBAAgBA,CAAC1G,EAAE,EAAEI,OAAO,EAAEuG,gBAAgB,EAAEC,cAAc,EAAEC,SAAS,EAAE;UAC5F7G,EAAE,CAACC,IAAI,CAAC0G,gBAAgB,GAAGC,cAAc,CAAC;UAC1C,OAAO5G,EAAE,CAAC8G,UAAU,CAACD,SAAS,CAAC;QACjC,CAAC;QACD,SAAS,EAAE,SAASE,iBAAiBA,CAAC/G,EAAE,EAAEI,OAAO,EAAEuG,gBAAgB,EAAEC,cAAc,EAAEC,SAAS,EAAE;UAC9F7G,EAAE,CAACC,IAAI,CAAC0G,gBAAgB,GAAGC,cAAc,CAAC;UAC1C,OAAO5G,EAAE,CAACgH,cAAc,CAACH,SAAS,GAAG,CAAC,CAAC;QACzC,CAAC;QACD,QAAQ,EAAE,SAASI,gBAAgBA,CAACjH,EAAE,EAAEI,OAAO,EAAEuG,gBAAgB,EAAEC,cAAc,EAAEC,SAAS,EAAE;UAC5F7G,EAAE,CAACC,IAAI,CAAC0G,gBAAgB,GAAGC,cAAc,CAAC;UAC1C,IAAIM,YAAY,GAAGpG,IAAI,CAACwB,GAAG,CAACxB,IAAI,CAACwB,GAAG,CAAClC,OAAO,CAACE,YAAY,GAAGsG,cAAc,EAAEC,SAAS,CAAC,EAAEnK,KAAK,CAACG,GAAG,CAACO,gBAAgB,CAAC;UACnH,OAAO4C,EAAE,CAACmH,cAAc,CAACD,YAAY,CAAC;QACxC;MACF;IACF,CAAC;IACDE,GAAG,EAAE;MACH,WAAW,EAAE,SAASC,iBAAiBA,CAACrH,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAEI,iBAAiB,EAAE;QACrF,IAAI/F,MAAM,GAAGF,gBAAgB,CAACC,OAAO,EAAE4F,aAAa,CAAChC,UAAU,CAAC;QAChEhE,EAAE,CAACC,IAAI,CAACI,MAAM,CAAC;QACf,OAAO+F,iBAAiB,CAACpG,EAAE,EAAEgG,aAAa,CAAC;MAC7C,CAAC;MACDS,QAAQ,EAAE;QACR,QAAQ,EAAE,SAASa,iBAAiBA,CAACtH,EAAE,EAAEgG,aAAa,EAAE;UACtD,OAAOhG,EAAE,CAAC8G,UAAU,CAACd,aAAa,CAAC/B,SAAS,CAAC;QAC/C,CAAC;QACD,SAAS,EAAE,SAASsD,kBAAkBA,CAACvH,EAAE,EAAEgG,aAAa,EAAE;UACxD,OAAOhG,EAAE,CAACgH,cAAc,CAAChB,aAAa,CAAC/B,SAAS,GAAG,CAAC,CAAC;QACvD,CAAC;QACD,QAAQ,EAAE,SAASuD,iBAAiBA,CAACxH,EAAE,EAAEgG,aAAa,EAAE;UACtD,OAAOhG,EAAE,CAACmH,cAAc,CAACnB,aAAa,CAAC/B,SAAS,CAAC;QACnD;MACF;IACF;EACF,CAAC;EAED,SAASsC,oBAAoBA,CAACvG,EAAE,EAAEI,OAAO,EAAE4D,UAAU,EAAE6C,SAAS,EAAET,iBAAiB,EAAE;IACnF,IAAIqB,UAAU,GAAGzD,UAAU,GAAGtH,KAAK,CAACG,GAAG,CAACO,gBAAgB;IACxD,IAAIsK,cAAc,GAAG5G,IAAI,CAACC,KAAK,CAAC0G,UAAU,GAAGrH,OAAO,CAACE,YAAY,CAAC;IAClE,IAAIsG,cAAc,GAAGa,UAAU,GAAGrH,OAAO,CAACE,YAAY;IAEtD,IAAIqH,QAAQ,GAAGvH,OAAO,CAACsB,YAAY,CAAC,CAAC,CAAC;IAEtC,IAAIkG,SAAS,GAAGD,QAAQ,CAAC3D,UAAU;IACnC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+H,cAAc,EAAE/H,CAAC,EAAE,EAAE;MACvCiI,SAAS,GAAG1G,YAAY,CAAClB,EAAE,EAAEI,OAAO,EAAEwH,SAAS,CAAC;IAClD;IACA,IAAIjB,gBAAgB,GAAGxG,gBAAgB,CAACC,OAAO,EAAEwH,SAAS,CAAC;IAE3D,OAAOxB,iBAAiB,CAACpG,EAAE,EAAEI,OAAO,EAAEuG,gBAAgB,EAAEC,cAAc,EAAEC,SAAS,CAAC;EACpF;EAEA,SAASL,yBAAyBA,CAACxG,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAEK,KAAK,EAAED,iBAAiB,EAAE;IACvF,IAAIyB,UAAU,GAAG,IAAIC,SAAS,CAAC9B,aAAa,CAAC/B,SAAS,CAAC;IAEvD,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEoI,GAAG,GAAG,CAAC,EAAEpI,CAAC,GAAG0G,KAAK,CAAC3G,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC9C,IAAIC,IAAI,GAAG2G,oBAAoB,CAACvG,EAAE,EAAEI,OAAO,EAAEiG,KAAK,CAAC1G,CAAC,CAAC,EAAEjD,KAAK,CAACG,GAAG,CAACO,gBAAgB,EAAE6I,mBAAmB,CAACC,IAAI,CAACO,QAAQ,CAACuB,MAAM,CAAC;MAC5H,KAAK,IAAIjF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnD,IAAI,CAACF,MAAM,EAAEqD,CAAC,EAAE,EAAE;QACpC8E,UAAU,CAACE,GAAG,EAAE,CAAC,GAAGnI,IAAI,CAACmD,CAAC,CAAC;MAC7B;IACF;IACA,IAAIkF,OAAO,GAAG,IAAIxL,UAAU,CAACoL,UAAU,EAAE,CAAC,EAAEpL,UAAU,CAACyL,aAAa,CAAC;IACrE,OAAO9B,iBAAiB,CAAC6B,OAAO,EAAE7H,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE4F,aAAa,CAAC/B,SAAS,CAAC;EAC3E;EAEA,SAASqC,oBAAoBA,CAACtG,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAE;IACxD,IAAImC,UAAU,GAAG,EAAE;IACnB,IAAIC,cAAc,GAAGpC,aAAa,CAAChC,UAAU;IAC7C,OAAOoE,cAAc,IAAI1L,KAAK,CAACG,GAAG,CAACE,YAAY,EAAE;MAC/CoL,UAAU,CAAC1F,IAAI,CAAC2F,cAAc,CAAC;MAC/BA,cAAc,GAAGhH,iBAAiB,CAACpB,EAAE,EAAEI,OAAO,EAAEgI,cAAc,CAAC;IACjE;IACA,OAAOD,UAAU;EACnB;EAEA,SAASpC,aAAaA,CAAC/F,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAErC,IAAI,EAAE;IACvD,IAAI8B,KAAK,GAAG,IAAI;IAEhB,IAAI4C,cAAc,GAChBrC,aAAa,CAAC/B,SAAS,GAAGvH,KAAK,CAACG,GAAG,CAACQ,sBAAsB,GAAG4I,mBAAmB,CAACC,IAAI,GAAGD,mBAAmB,CAACmB,GAAG;IACjH,IAAIhB,iBAAiB,GAAGiC,cAAc,CAAC5B,QAAQ,CAAC/J,KAAK,CAACG,GAAG,CAACgC,KAAK,CAACO,YAAY,CAACuE,IAAI,CAAC,CAAC;IAEnF,IAAIyC,iBAAiB,EAAE;MACrBX,KAAK,GAAG4C,cAAc,CAACC,SAAS,CAACtI,EAAE,EAAEI,OAAO,EAAE4F,aAAa,EAAEI,iBAAiB,CAAC;IACjF;IACA,OAAOX,KAAK;EACd;;EAEA;EACA,IAAIjJ,SAAS,GAAG,SAAAA,CAAU+L,WAAW,EAAE;IACrC,IAAI,CAACvI,EAAE,GAAG,IAAIvD,UAAU,CAAC8L,WAAW,EAAE,CAAC,EAAE9L,UAAU,CAACyL,aAAa,CAAC;EACpE,CAAC;EAED1L,SAAS,CAACgM,SAAS,GAAG;IACpB;AACJ;AACA;AACA;IAEIC,WAAW,EAAE,SAAAA,CAAA,EAAY;MACvB,IAAI,CAAC1I,SAAS,CAAC,IAAI,CAACC,EAAE,CAAC,EAAE;QACvB,OAAO;UAAC0I,KAAK,EAAE;QAAwB,CAAC;MAC1C;MACA,IAAI,IAAI,CAACC,QAAQ,IAAI,IAAI,EAAE;QACzB,IAAI,CAACA,QAAQ,GAAGrH,YAAY,CAAC,IAAI,CAACtB,EAAE,CAAC;MACvC;MACA,OAAO,IAAI,CAAC2I,QAAQ,CAAChH,UAAU;IACjC,CAAC;IACD;AACJ;AACA;AACA;IAEIiH,aAAa,EAAE,SAAAA,CAAUC,MAAM,EAAE;MAC/B,IAAIC,UAAU,GAAG,OAAOD,MAAM,KAAK,QAAQ,GAAG,IAAI,CAACF,QAAQ,CAAChH,UAAU,CAACiD,WAAW,CAACiE,MAAM,CAAC,GAAGA,MAAM;MACnG,IAAI7C,aAAa,GAAG,IAAI,CAAC2C,QAAQ,CAACjH,YAAY,CAACoH,UAAU,CAACC,MAAM,CAAC;MACjE,IAAIC,SAAS,GAAGjD,aAAa,CAAC,IAAI,CAAC/F,EAAE,EAAE,IAAI,CAAC2I,QAAQ,EAAE3C,aAAa,EAAEV,YAAY,CAACU,aAAa,CAAC,CAAC;MAEjG,OAAO;QAACiD,QAAQ,EAAEH,UAAU,CAACG,QAAQ;QAAEC,OAAO,EAAEF;MAAS,CAAC;IAC5D;EACF,CAAC;EAED,OAAOxM,SAAS;AAElB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}